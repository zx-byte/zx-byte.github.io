<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>暑假打卡第一天（单链表）</title>
    <url>/2020/06/28/%E6%9A%91%E5%81%87%E6%89%93%E5%8D%A1%E7%AC%AC%E4%B8%80%E5%A4%A9%EF%BC%88%E5%8D%95%E9%93%BE%E8%A1%A8%EF%BC%89/</url>
    <content><![CDATA[<p>@<a href="目录">TOC</a></p>
<h1 id="1-单链表结点定义"><a href="#1-单链表结点定义" class="headerlink" title="1.单链表结点定义"></a>1.单链表结点定义</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> data;<span class="comment">//data中存放结点数据域</span></span><br><span class="line">	LNode* next;<span class="comment">//指向后继结点的指针</span></span><br><span class="line">&#125;LNode;<span class="comment">//定义单链表结点类型</span></span><br></pre></td></tr></table></figure>

<p>结点时内存中一片由用户分配的存储空间，只有一个地址来表示它的存在，没有显式的名称，因此一般会在分配链表结点空间的时候，同时定义一个指针，来存储这片空间的地址（这个过程一般叫做指针指向结点），并且通常用这个指针的名称作为结点的名称。<br>例如，下边这句代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">LNode* p = (LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br></pre></td></tr></table></figure>

<p>用户分配了一片<font color=red size=3><strong>LNode</strong></font>型空间，也就是构造了一个<font color=red size=3><strong>LNode</strong></font>型的结点，这时候定义一个名字为p的指针来指向这个结点，同时我们也把p当作这个结点的名字。<br> <font color=red size=3> <strong>注：这里的命名了两个东西，一个是结点，另一个是指向这个结点的指针。</strong></font></p>
<h1 id="2-单链表的操作"><a href="#2-单链表的操作" class="headerlink" title="2.单链表的操作"></a>2.单链表的操作</h1><p><strong>1.创建结点</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建结点</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> LNode* <span class="title">create_node</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//给每个结点分配大小一样的空间</span></span><br><span class="line">	LNode* p = (LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">	<span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"结点空间分配失败!"</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//由于结构体在未初始化的时候一样是脏数据，所以要清</span></span><br><span class="line">	<span class="built_in">memset</span>(p, <span class="number">0</span>, <span class="keyword">sizeof</span>(LNode*));</span><br><span class="line">	p-&gt;data = data;</span><br><span class="line">	p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2.插入结点</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//尾插法</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">tail_insert</span><span class="params">(LNode* H, LNode* New)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//获取当前节点的位置</span></span><br><span class="line">	LNode* p = H;</span><br><span class="line">	<span class="comment">//遍历链表，直到找到最后一个结点</span></span><br><span class="line">	<span class="keyword">while</span> (p-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		p=p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//如果跳出以上循环，所以已经到了NULL的这个位置</span></span><br><span class="line">	<span class="comment">//此时直接把新插入的节点赋值给NULL这个位置 </span></span><br><span class="line">	p-&gt;next = New;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//头插法</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">top_insert</span><span class="params">(LNode* H, LNode* New)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//获取当前节点的位置</span></span><br><span class="line">	LNode* p = H;</span><br><span class="line">	New-&gt;next = p-&gt;next;</span><br><span class="line">	p-&gt;next = New;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>3.遍历单链表</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//链表的遍历 </span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Print_node</span><span class="params">(LNode* H)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//获取当前节点的位置</span></span><br><span class="line">	LNode* p = H;</span><br><span class="line">	<span class="comment">//获取当前结点的下一位置</span></span><br><span class="line">	p = p-&gt;next;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span> (p-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt;<span class="string">"data:"</span>&lt;&lt; p-&gt;data &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"data:"</span> &lt;&lt; p-&gt;data &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>4.删除结点</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//删除链表中的节点 </span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">detele_list_node</span><span class="params">(LNode* H, <span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//获取当前节点的位置</span></span><br><span class="line">	LNode* p = H;</span><br><span class="line">	LNode* pre = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (p-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="comment">//保存当前结点的前一个结点</span></span><br><span class="line">		pre = p;</span><br><span class="line">		<span class="comment">//然后P后移</span></span><br><span class="line">		p=p-&gt;next;</span><br><span class="line">		<span class="comment">//判断是否找到了要删除的数据</span></span><br><span class="line">		<span class="keyword">if</span> (p-&gt;data == data) &#123;</span><br><span class="line">			<span class="comment">//两种情况，一种是普通节点，还有一种是尾节点</span></span><br><span class="line">			<span class="comment">//普通节点</span></span><br><span class="line">			<span class="keyword">if</span> (p-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">				pre-&gt;next = p-&gt;next;</span><br><span class="line">				<span class="built_in">free</span>(p);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				pre -&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">				<span class="built_in">free</span>(p);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"没有要删除的节点!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>5.单链表逆置</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//链表逆置</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">trave_list</span><span class="params">(LNode* H)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//1.保存当前结点和第一个有效结点</span></span><br><span class="line">	LNode* p = H-&gt;next;</span><br><span class="line">	LNode* pBack;</span><br><span class="line">	<span class="comment">//2.若无有效结点或只有一个结点，则不进行任何操作</span></span><br><span class="line">	<span class="keyword">if</span> (p == <span class="literal">NULL</span> || p-&gt;next == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//3.遍历链表</span></span><br><span class="line">	<span class="keyword">while</span> (p-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="comment">//3.1 保存第一个结点的下一个结点的地址</span></span><br><span class="line">		pBack = p-&gt;next;</span><br><span class="line">		<span class="comment">//3.2 将第一个有效结点放入尾部</span></span><br><span class="line">		<span class="keyword">if</span> (p == H-&gt;next) &#123;</span><br><span class="line">			p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//3.3  如果不是第一个有效结点，则进行头插操作</span></span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			p-&gt;next = H-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">		H-&gt;next = p;</span><br><span class="line">		p = pBack;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//4.手动加入最后一个结点</span></span><br><span class="line">	top_insert(H, p); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="3-链表和顺序表的比较"><a href="#3-链表和顺序表的比较" class="headerlink" title="3.链表和顺序表的比较"></a>3.链表和顺序表的比较</h1><p><strong>1.顺序表存储（典型的数组）</strong><br>     原理：顺序表存储是将数据元素放到一块连续的内存存储空间，相邻数据元素的存放地址也相邻（逻辑与物理统一）。<br>     优点：（1）空间利用率高。（局部性原理，连续存放，命中率高）<br>           （2）存取速度高效，通过下标来直接存储。<br>     缺点：（1）插入和删除比较慢，比如：插入或者删除一个元素时，整个表需要遍历移动元素来重新排一次顺序。<br>           （2）不可以增长长度，有空间限制,当需要存取的元素个数可能多于顺序表的元素个数时,会出现”溢出”问题.当元素个数远少于预先分配的空间时,空间浪费巨大。<br>     时间性能 :查找 O(1) ,插入和删除O（n）。<br><strong>2.链表存储</strong><br>    原理：链表存储是在程序运行过程中动态的分配空间，只要存储器还有空间，就不会发生存储溢出问题，相邻数据元素可随意存放，但所占存储空间分两部分，一部分存放结点值，另一部分存放表示结点关系间的指针。<br>    优点：（1）存取某个元素速度慢。<br>          （2）插入和删除速度快，保留原有的物理顺序，比如：插入或者删除一个元素时，只需要改变指针指向即可。<br>          （3）没有空间限制,存储元素的个数无上限,基本只与内存空间大小有关.<br>    缺点：（1）占用额外的空间以存储指针(浪费空间，不连续存放，malloc开辟，空间碎片多)<br>          （2）查找速度慢，因为查找时，需要循环链表访问，需要从开始节点一个一个节点去查找元素访问。<br>    时间性能 :查找 O(n) ,插入和删除O（1）。<br><font color=red size=3><strong>*频繁的查找却很少的插入和删除操作可以用顺序表存储，堆排序,二分查找适宜用顺序表.<br>*如果频繁的插入和删除操作很少的查询就可以使用链表存储<br>*顺序表适宜于做查找这样的静态操作；链表适宜于做插入、删除这样的动态操作。<br>*若线性表长度变化不大，如果事先知道线性表的大致长度，比如一年12月，一周就是星期一至星期日共七天，且其主要操作是查找，则采用顺序表；若线性表长度变化较大或根本不知道多大时，且其主要操作是插入、删除，则采用链表，这样可以不需要考虑存储空间的大小问题。<br>*顺序表:顺序存储，随机读取<br>链式:随机存储,顺序读取(必须遍历)</strong></font></p>
]]></content>
  </entry>
  <entry>
    <title>暑假打卡第二天(双链表和循环链表)</title>
    <url>/2020/06/29/%E6%9A%91%E5%81%87%E6%89%93%E5%8D%A1%E7%AC%AC%E4%BA%8C%E5%A4%A9-%E5%8F%8C%E9%93%BE%E8%A1%A8%E5%92%8C%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<p>@<a href="目录">TOC</a></p>
<h1 id="1-双链表定义"><a href="#1-双链表定义" class="headerlink" title="1.双链表定义"></a>1.双链表定义</h1><p><font color="red"><strong>首先不管是单链表还是双链表或者循环双链表，都是为了提高访问效率，比如同样的插入操作，顺序表需要用数组移动元素，访问效率比较差，相反链表只需要移动指针，而且顺序表是有最大空间的，而链表没有。</strong></font></p>
<p>单链表只能由开始结点走到终端结点，而不能由终端结点走到开始结点。如果要求输出从终端结点到开始结点的序列，单链表操作起来非常麻烦，于是引入了双链表。双链表就是在单链表结点上增加了一个指针域，指向当前结点的前驱。</p>
<h1 id="2-双链表结点定义"><a href="#2-双链表结点定义" class="headerlink" title="2.双链表结点定义"></a>2.双链表结点定义</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DLNode</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> data;<span class="comment">//存放数据</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">DLNode</span>* <span class="title">prior</span>;</span><span class="comment">//指向前驱的指针</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">DLNode</span>* <span class="title">next</span>;</span><span class="comment">//指向后继的指针</span></span><br><span class="line">&#125;DLNode;</span><br></pre></td></tr></table></figure>
<h1 id="3-双链表的基本操作"><a href="#3-双链表的基本操作" class="headerlink" title="3.双链表的基本操作"></a>3.双链表的基本操作</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DLNode</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> data;<span class="comment">//存放数据</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">DLNode</span>* <span class="title">prior</span>;</span><span class="comment">//指向前驱的指针</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">DLNode</span>* <span class="title">next</span>;</span><span class="comment">//指向后继的指针</span></span><br><span class="line">&#125;DLNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建结点</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> DLNode* <span class="title">create_node</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//给每个结点分配大小一样的空间</span></span><br><span class="line">	DLNode* p = (DLNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DLNode));</span><br><span class="line">	<span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"结点空间分配失败!"</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//由于结构体在未初始化的时候一样是脏数据，所以要清</span></span><br><span class="line">	<span class="built_in">memset</span>(p, <span class="number">0</span>, <span class="keyword">sizeof</span>(DLNode*));</span><br><span class="line">	p-&gt;data = data;</span><br><span class="line">	p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">	p-&gt;prior = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//尾插法创建双链表</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">tail_insert</span><span class="params">(DLNode* L, <span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	DLNode* s, * r;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	r = L;<span class="comment">//r始终指向终端结点，开始头结点也是尾结点</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">		s = (DLNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DLNode));</span><br><span class="line">		s-&gt;data = a[i];</span><br><span class="line">		r-&gt;next = s;</span><br><span class="line">		s-&gt;prior = r;</span><br><span class="line">		r = s;</span><br><span class="line">	&#125;</span><br><span class="line">	r-&gt;next = <span class="literal">NULL</span>;        </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查找结点</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> DLNode* <span class="title">findNode</span><span class="params">(DLNode* C, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">	DLNode* p = C-&gt;next;</span><br><span class="line">	<span class="keyword">while</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (p-&gt;data == x) &#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取双链表的长度</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getListLength</span><span class="params">(DLNode* L)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (L-&gt;next == L)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"链表为空"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	DLNode* p;</span><br><span class="line">	p = L;</span><br><span class="line">	<span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (p-&gt;next != L)</span><br><span class="line">	&#123;</span><br><span class="line">		j++;</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入结点</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">insertNode</span><span class="params">(DLNode* L,<span class="keyword">int</span> i,<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (i&lt;<span class="number">1</span> || i&gt;getListLength(L))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"输入不合法！"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">	&#125;</span><br><span class="line">	DLNode *p, *q;</span><br><span class="line">	p = L;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i - <span class="number">1</span>; j++)   <span class="comment">//定位到要插入结点的前一个</span></span><br><span class="line">	&#123;</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	q = (DLNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DLNode*));</span><br><span class="line">	<span class="keyword">if</span> (!q)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"内存分配失败！"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">	&#125;</span><br><span class="line">	q-&gt;data = num;</span><br><span class="line">	q-&gt;next = p-&gt;next;</span><br><span class="line">	q-&gt;prior = p;</span><br><span class="line">	p-&gt;next = q;</span><br><span class="line">	q-&gt;next-&gt;prior = q;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印双链表</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printLinkedList</span><span class="params">(DLNode* L)</span> </span>&#123;</span><br><span class="line">	DLNode* p;</span><br><span class="line">	p = L;</span><br><span class="line">	<span class="keyword">if</span> (L-&gt;next == L)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"链表为空！"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; getListLength(L); i++)</span><br><span class="line">	&#123;</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; p-&gt;data &lt;&lt; <span class="string">"  "</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除结点</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">deleteListElem</span><span class="params">(DLNode* L, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (i&lt;<span class="number">1</span> || i&gt;getListLength(L))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"输入不合法！"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">	&#125;</span><br><span class="line">	DLNode *p, *q;</span><br><span class="line">	p = L;</span><br><span class="line">	<span class="keyword">int</span> j;</span><br><span class="line">	<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; i - <span class="number">1</span>; j++)   <span class="comment">//定位到要删除的结点的前一个</span></span><br><span class="line">	&#123;</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	q = p-&gt;next;</span><br><span class="line">	p-&gt;next = q-&gt;next;</span><br><span class="line">	q-&gt;next-&gt;prior = p;</span><br><span class="line">	<span class="built_in">free</span>(q);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="4-循环单链表"><a href="#4-循环单链表" class="headerlink" title="4.循环单链表"></a>4.循环单链表</h1><p><strong>1.知道了单链表结构后，循环单链表就非常简单了。只要将单链表的最后一个指针域（空指针）指向链表的第一个结点即可。</strong><br><font color="red"><strong>循环单链表可以实现从任何一个结点出发访问链表中的任何结点，而单链表从任一结点出发只能访问这个结点及其后边的所以结点。带头结点的循环单链表，当head等于head-&gt;next时，链表为空；不带头结点的循环单链表，当head等于NULL时，链表为空。</strong></font><br><img src="https://img-blog.csdnimg.cn/2020062911561238.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTE3MjA0Mw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><strong>2.单向循环链表的初始化：从上面的示意图可以知道，单向循环链表最后一个结点的指针是指向头结点的，那么当只有一个结点的时候就是头结点的指针指自己。</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> data;</span><br><span class="line">	LNode* next;</span><br><span class="line">&#125;LNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">//循环单链表</span></span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">init_node</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//创建一个头结点</span></span><br><span class="line">	LNode* H = (LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">	<span class="keyword">if</span> (H == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"初始化失败!"</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">memset</span>(H, <span class="number">0</span>, <span class="keyword">sizeof</span>(LNode*));</span><br><span class="line">	H-&gt;next = H;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>3.单向循环链表的创建过程：和单向链表的创建过程相似，区别就是最后一个结点的指针是指着头结点的。所以程序实现的时候每次新建一个结点的时候都是让它的指针指向头结点。</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//循环单链表</span></span><br><span class="line"><span class="comment">//创建结点</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> LNode* <span class="title">create_node</span><span class="params">(LNode* H,<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">	LNode* p = H;</span><br><span class="line">	<span class="comment">//给每个结点分配大小一样的空间</span></span><br><span class="line">	LNode* q = (LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">	<span class="keyword">if</span> (q == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"结点空间分配失败!"</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//由于结构体在未初始化的时候一样是脏数据，所以要清</span></span><br><span class="line">	<span class="built_in">memset</span>(q, <span class="number">0</span>, <span class="keyword">sizeof</span>(LNode*));</span><br><span class="line">	q-&gt;data = data;</span><br><span class="line">	p-&gt;next = q;</span><br><span class="line">	q-&gt;next = H;</span><br><span class="line">	<span class="keyword">return</span> q;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>4.单向循环链表插入结点过程：因为这个时候是往链表中插入结点，结点已经构成一个环了，所以直接让新插入结点的指针指向下一个结点就行。就算插入的是最后一个位置，让它的指针指向下一个结点也符合条件，因为最后一个位置的下一个结点就是头结点。</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在第i个位置之前插入元素</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">insertListElem</span><span class="params">(LinkedList&amp; L, <span class="keyword">int</span> i, <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (i&lt;<span class="number">1</span> || i&gt;getListLength(L))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"输入不合法！"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">	&#125;</span><br><span class="line">	LinkedList p, q;</span><br><span class="line">	p = L;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i - <span class="number">1</span>; j++)   <span class="comment">//定位到要插入结点的前一个</span></span><br><span class="line">	&#123;</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	q = (LinkedList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">	<span class="keyword">if</span> (!q)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"内存分配失败！"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">	&#125;</span><br><span class="line">	q-&gt;data = num;</span><br><span class="line">	q-&gt;next = p-&gt;next;</span><br><span class="line">	p-&gt;next = q;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>5.单向循环链表删除结点过程：结合单向链表删除结点过程和上面单向循环链表插入结点过程的解释，那么这里就不难理解了。</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//删除第i个元素</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">deleteListElem</span><span class="params">(LinkedList&amp; L, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (i&lt;<span class="number">1</span> || i&gt;getListLength(L))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"输入不合法！"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">	&#125;</span><br><span class="line">	LinkedList p, q;</span><br><span class="line">	p = L;</span><br><span class="line">	<span class="keyword">int</span> j;</span><br><span class="line">	<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; i - <span class="number">1</span>; j++)   <span class="comment">//定位到要删除的结点的前一个</span></span><br><span class="line">	&#123;</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	q = p-&gt;next;</span><br><span class="line">	p-&gt;next = p-&gt;next-&gt;next;</span><br><span class="line">	<span class="built_in">free</span>(q);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><font color="red"><strong>6.循环单链表的具体操作代码</strong></font></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"iostream"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;LNode, * LinkedList;</span><br><span class="line"><span class="comment">//创建链表</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">createLinkedList</span><span class="params">(LinkedList&amp; L, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (i &lt; <span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"输入不合法！"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">	&#125;</span><br><span class="line">	L = (LinkedList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">	<span class="keyword">if</span> (!L)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"内存分配失败!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">	&#125;</span><br><span class="line">	LinkedList p, q;</span><br><span class="line">	L-&gt;next = L;</span><br><span class="line">	p = L;</span><br><span class="line">	<span class="keyword">int</span> j;</span><br><span class="line">	<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; i; j++)</span><br><span class="line">	&#123;</span><br><span class="line">		q = (LinkedList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">		<span class="keyword">if</span> (!q)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="string">"内存分配失败！"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">			<span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"请输入第"</span> &lt;&lt; j + <span class="number">1</span> &lt;&lt; <span class="string">"个元素："</span>;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; q-&gt;data;</span><br><span class="line">		p-&gt;next = q;</span><br><span class="line">		q-&gt;next = L;</span><br><span class="line">		p = q;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取链表的长度</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getListLength</span><span class="params">(LinkedList&amp; L)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (L-&gt;next == L)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"链表为空"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	LinkedList p;</span><br><span class="line">	p = L;</span><br><span class="line">	<span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (p-&gt;next != L)</span><br><span class="line">	&#123;</span><br><span class="line">		j++;</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//打印链表</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printLinkedList</span><span class="params">(LinkedList&amp; L)</span> </span>&#123;</span><br><span class="line">	LinkedList p;</span><br><span class="line">	p = L;</span><br><span class="line">	<span class="keyword">if</span> (L-&gt;next == L)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"链表为空！"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; getListLength(L); i++)</span><br><span class="line">	&#123;</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; p-&gt;data &lt;&lt; <span class="string">"  "</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在第i个位置之前插入元素</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">insertListElem</span><span class="params">(LinkedList&amp; L, <span class="keyword">int</span> i, <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (i&lt;<span class="number">1</span> || i&gt;getListLength(L))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"输入不合法！"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">	&#125;</span><br><span class="line">	LinkedList p, q;</span><br><span class="line">	p = L;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i - <span class="number">1</span>; j++)   <span class="comment">//定位到要插入结点的前一个</span></span><br><span class="line">	&#123;</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	q = (LinkedList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">	<span class="keyword">if</span> (!q)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"内存分配失败！"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">	&#125;</span><br><span class="line">	q-&gt;data = num;</span><br><span class="line">	q-&gt;next = p-&gt;next;</span><br><span class="line">	p-&gt;next = q;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//删除第i个元素</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">deleteListElem</span><span class="params">(LinkedList&amp; L, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (i&lt;<span class="number">1</span> || i&gt;getListLength(L))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"输入不合法！"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">	&#125;</span><br><span class="line">	LinkedList p, q;</span><br><span class="line">	p = L;</span><br><span class="line">	<span class="keyword">int</span> j;</span><br><span class="line">	<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; i - <span class="number">1</span>; j++)   <span class="comment">//定位到要删除的结点的前一个</span></span><br><span class="line">	&#123;</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	q = p-&gt;next;</span><br><span class="line">	p-&gt;next = p-&gt;next-&gt;next;</span><br><span class="line">	<span class="built_in">free</span>(q);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//查找并返回第i个位置的元素</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getElem</span><span class="params">(LinkedList&amp; L, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (i&lt;<span class="number">1</span> || i&gt;getListLength(L))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"输入不合法！"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">	&#125;</span><br><span class="line">	LinkedList p;</span><br><span class="line">	p = L;</span><br><span class="line">	<span class="keyword">int</span> j;</span><br><span class="line">	<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; i; j++)</span><br><span class="line">	&#123;</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> p-&gt;data;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在链表中查找节点值等于num的位置，并返回</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">searchElem</span><span class="params">(LinkedList&amp; L, <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">	LinkedList p;</span><br><span class="line">	p = L-&gt;next;</span><br><span class="line">	<span class="keyword">int</span> j = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> ((p-&gt;data != num) &amp;&amp; (j &lt;= getListLength(L)))</span><br><span class="line">	&#123;</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">		j++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (j &lt;= getListLength(L))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> j;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"查找无该值！"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//销毁链表</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">destroylinkedlist</span><span class="params">(LinkedList&amp; L)</span> </span>&#123;</span><br><span class="line">	LinkedList p, q;</span><br><span class="line">	p = q = L-&gt;next;</span><br><span class="line">	<span class="keyword">while</span> (p != L)</span><br><span class="line">	&#123;</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">		<span class="built_in">free</span>(q);</span><br><span class="line">		q = p;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">free</span>(L);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//清空链表</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">clearList</span><span class="params">(LinkedList&amp; L)</span> </span>&#123;</span><br><span class="line">	LinkedList p, q;</span><br><span class="line">	p = q = L-&gt;next;</span><br><span class="line">	<span class="keyword">if</span> (L == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (p != L)</span><br><span class="line">	&#123;</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">		<span class="built_in">free</span>(q);</span><br><span class="line">		q = p;</span><br><span class="line">	&#125;</span><br><span class="line">	L-&gt;next = L;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>暑假打卡第三天(栈和队列)</title>
    <url>/2020/06/30/%E6%9A%91%E5%81%87%E6%89%93%E5%8D%A1%E7%AC%AC%E4%B8%89%E5%A4%A9-%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<p>@<a href="目录">toc</a></p>
<h1 id="一，栈的基本概念"><a href="#一，栈的基本概念" class="headerlink" title="一，栈的基本概念"></a>一，栈的基本概念</h1><h2 id="1，栈的定义"><a href="#1，栈的定义" class="headerlink" title="1，栈的定义"></a>1，栈的定义</h2><p><font color="red"><strong>栈是一种只能在一端进行插入或删除操作的线性表。</strong></font><br>其中允许插入或删除的一端成为栈顶(top)。表的另一端成为栈底，<font color="red"><strong>栈底是固定不变的。</strong></font></p>
<h2 id="2，栈的特点"><a href="#2，栈的特点" class="headerlink" title="2，栈的特点"></a>2，栈的特点</h2><p><font color="red"><strong>栈的主要特点是先进后出。</strong></font></p>
<h2 id="3，栈的存储结构"><a href="#3，栈的存储结构" class="headerlink" title="3，栈的存储结构"></a>3，栈的存储结构</h2><p><strong>可用顺序表和链表来存储栈。按照存储结构可分为两种:<br>(1)顺序栈基本操作：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxSize 50</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> data[maxSize];<span class="comment">//存放栈中元素</span></span><br><span class="line">	<span class="keyword">int</span> top;<span class="comment">//栈顶指针</span></span><br><span class="line">&#125;sqStack;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化栈</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">initStack</span><span class="params">(sqStack&amp; st)</span> </span>&#123;</span><br><span class="line">	st.top = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断栈空</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span>  <span class="title">isEmpty</span><span class="params">(sqStack&amp; st)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (st.top == <span class="number">-1</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//出栈</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">(sqStack&amp; st,<span class="keyword">int</span> &amp;x)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//出栈前先判断栈是否为空，如果栈空，则不能进行出栈操作</span></span><br><span class="line">	<span class="keyword">if</span> (st.top == <span class="number">-1</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	x = st.data[st.top];</span><br><span class="line">	st.top--;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//入栈</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">push</span><span class="params">(sqStack&amp; st, <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="comment">//出栈前先判断栈是否满，如果栈满，则不能进行入栈操作</span></span><br><span class="line">	<span class="keyword">if</span> (st.top == maxSize<span class="number">-1</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	st.top++;</span><br><span class="line">	st.data[st.top]=x;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>(2)链式栈基本操作：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> data;<span class="comment">//数据域</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>* <span class="title">next</span>;</span><span class="comment">//指针域</span></span><br><span class="line">&#125;LNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化栈</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">initStack</span><span class="params">(LNode*&amp; st)</span> </span>&#123;</span><br><span class="line">	st = (LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode*));<span class="comment">//制造一个头结点</span></span><br><span class="line">	st-&gt;next == <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断栈空</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span>  <span class="title">isEmpty</span><span class="params">(LNode*&amp; st)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (st-&gt;next==<span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//出栈</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">(LNode*&amp; st, <span class="keyword">int</span>&amp; x)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//出栈前先判断栈是否为空，如果栈空，则不能进行出栈操作</span></span><br><span class="line">	<span class="keyword">if</span> (st-&gt;next == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	LNode* p;</span><br><span class="line">	p = st-&gt;next;</span><br><span class="line">	x = p-&gt;data;</span><br><span class="line">	st-&gt;next = p-&gt;next;</span><br><span class="line">	<span class="built_in">free</span>(p);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//入栈</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(LNode*&amp; st, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">	LNode* p;</span><br><span class="line">	p = (LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode*));<span class="comment">//为入栈元素申请空间</span></span><br><span class="line">	p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	p-&gt;data = x;</span><br><span class="line">	p-&gt;next = st-&gt;next;</span><br><span class="line">	st-&gt;next = p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="二，队列的基本概念"><a href="#二，队列的基本概念" class="headerlink" title="二，队列的基本概念"></a>二，队列的基本概念</h1><h2 id="1，队列的定义"><a href="#1，队列的定义" class="headerlink" title="1，队列的定义"></a>1，队列的定义</h2><p><font color="red"><strong>队列是一种只能在一端进行插入，在另一端进行删除操作的线性表。</strong></font><br>其中允许插的一端成为队尾(rear)，可进行删除的一端称为队头(front).</p>
<h2 id="2，队列的特点"><a href="#2，队列的特点" class="headerlink" title="2，队列的特点"></a>2，队列的特点</h2><p><font color="red"><strong>队列的主要特点是先进先出。</strong></font></p>
<h2 id="3，队列的存储结构"><a href="#3，队列的存储结构" class="headerlink" title="3，队列的存储结构"></a>3，队列的存储结构</h2><p><strong>可用顺序表和链表来存储队列。按照存储结构可分为两种:<br>(1)顺序队列基本操作：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxSize 50</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> data[maxSize];</span><br><span class="line">	<span class="keyword">int</span> front;<span class="comment">//队首指针</span></span><br><span class="line">	<span class="keyword">int</span> rear;<span class="comment">//队尾指针</span></span><br><span class="line">&#125;sqQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化队列</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">initQueue</span><span class="params">(sqQueue&amp; qu)</span> </span>&#123;</span><br><span class="line">	qu.front = qu.rear = <span class="number">0</span>;<span class="comment">//队头和队尾相等且为0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判空</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">isEmpty</span><span class="params">(sqQueue&amp; qu)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (qu.front == qu.rear) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//入队</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">enQueue</span><span class="params">(sqQueue&amp; qu,<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//先判断队列是否满</span></span><br><span class="line">	<span class="keyword">if</span> ((qu.rear + <span class="number">1</span>) % maxSize == qu.front) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//在这里存入元素和移动指针顺序无所谓（和栈不同）</span></span><br><span class="line">	qu.data[qu.rear] = x;</span><br><span class="line">	qu.rear = (qu.rear + <span class="number">1</span>)%maxSize;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//出队</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">deQueue</span><span class="params">(sqQueue&amp; qu, <span class="keyword">int</span>&amp; x)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//先判断队列是否为空</span></span><br><span class="line">	<span class="keyword">if</span> (qu.rear == qu.front) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	qu.front = (qu.front + <span class="number">1</span>) % maxSize;</span><br><span class="line">	x = qu.data[qu.front];</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>(2)链队的基本操作：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">QNode</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">QNode</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;QNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	QNode* front;<span class="comment">//队首指针</span></span><br><span class="line">	QNode* rear;<span class="comment">//队尾指针</span></span><br><span class="line">&#125;LiQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">initQueue</span><span class="params">(LiQueue*&amp; lqu)</span> </span>&#123;</span><br><span class="line">	lqu= (LiQueue*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LiQueue*));</span><br><span class="line">	lqu-&gt;front = lqu-&gt;rear = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判空</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">isEmpty</span><span class="params">(LiQueue* lqu)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (lqu-&gt;front == <span class="literal">NULL</span> || lqu-&gt;rear == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//入队</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">enQueue</span><span class="params">(LiQueue* lqu, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">	QNode* p;</span><br><span class="line">	p= (QNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(QNode*));</span><br><span class="line">	p-&gt;data = x;</span><br><span class="line">	p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">if</span> (lqu-&gt;rear == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		lqu-&gt;rear-&gt;next = p;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		lqu-&gt;rear-&gt;next = p;</span><br><span class="line">		lqu-&gt;rear = p;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//出队</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">deQueue</span><span class="params">(LiQueue* lqu, <span class="keyword">int</span>&amp; x)</span> </span>&#123;</span><br><span class="line">	QNode* p;</span><br><span class="line">	<span class="comment">//先判空</span></span><br><span class="line">	<span class="keyword">if</span> (lqu-&gt;rear == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		p = lqu-&gt;front;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (lqu-&gt;front == lqu-&gt;rear) &#123;</span><br><span class="line">		lqu-&gt;front = lqu-&gt;rear = <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		lqu-&gt;front = lqu-&gt;front-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	x = p-&gt;data;</span><br><span class="line">	<span class="built_in">free</span>(p);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
</search>
