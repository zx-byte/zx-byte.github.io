<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>暑假打卡第一天（单链表）</title>
    <url>/2020/06/28/%E6%9A%91%E5%81%87%E6%89%93%E5%8D%A1%E7%AC%AC%E4%B8%80%E5%A4%A9%EF%BC%88%E5%8D%95%E9%93%BE%E8%A1%A8%EF%BC%89/</url>
    <content><![CDATA[<p>@<a href="目录">TOC</a></p>
<h1 id="1-单链表结点定义"><a href="#1-单链表结点定义" class="headerlink" title="1.单链表结点定义"></a>1.单链表结点定义</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> data;<span class="comment">//data中存放结点数据域</span></span><br><span class="line">	LNode* next;<span class="comment">//指向后继结点的指针</span></span><br><span class="line">&#125;LNode;<span class="comment">//定义单链表结点类型</span></span><br></pre></td></tr></table></figure>

<p>结点时内存中一片由用户分配的存储空间，只有一个地址来表示它的存在，没有显式的名称，因此一般会在分配链表结点空间的时候，同时定义一个指针，来存储这片空间的地址（这个过程一般叫做指针指向结点），并且通常用这个指针的名称作为结点的名称。<br>例如，下边这句代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">LNode* p = (LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br></pre></td></tr></table></figure>

<p>用户分配了一片<font color=red size=3><strong>LNode</strong></font>型空间，也就是构造了一个<font color=red size=3><strong>LNode</strong></font>型的结点，这时候定义一个名字为p的指针来指向这个结点，同时我们也把p当作这个结点的名字。<br> <font color=red size=3> <strong>注：这里的命名了两个东西，一个是结点，另一个是指向这个结点的指针。</strong></font></p>
<h1 id="2-单链表的操作"><a href="#2-单链表的操作" class="headerlink" title="2.单链表的操作"></a>2.单链表的操作</h1><p><strong>1.创建结点</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建结点</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> LNode* <span class="title">create_node</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//给每个结点分配大小一样的空间</span></span><br><span class="line">	LNode* p = (LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">	<span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"结点空间分配失败!"</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//由于结构体在未初始化的时候一样是脏数据，所以要清</span></span><br><span class="line">	<span class="built_in">memset</span>(p, <span class="number">0</span>, <span class="keyword">sizeof</span>(LNode*));</span><br><span class="line">	p-&gt;data = data;</span><br><span class="line">	p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2.插入结点</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//尾插法</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">tail_insert</span><span class="params">(LNode* H, LNode* New)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//获取当前节点的位置</span></span><br><span class="line">	LNode* p = H;</span><br><span class="line">	<span class="comment">//遍历链表，直到找到最后一个结点</span></span><br><span class="line">	<span class="keyword">while</span> (p-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		p=p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//如果跳出以上循环，所以已经到了NULL的这个位置</span></span><br><span class="line">	<span class="comment">//此时直接把新插入的节点赋值给NULL这个位置 </span></span><br><span class="line">	p-&gt;next = New;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//头插法</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">top_insert</span><span class="params">(LNode* H, LNode* New)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//获取当前节点的位置</span></span><br><span class="line">	LNode* p = H;</span><br><span class="line">	New-&gt;next = p-&gt;next;</span><br><span class="line">	p-&gt;next = New;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>3.遍历单链表</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//链表的遍历 </span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Print_node</span><span class="params">(LNode* H)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//获取当前节点的位置</span></span><br><span class="line">	LNode* p = H;</span><br><span class="line">	<span class="comment">//获取当前结点的下一位置</span></span><br><span class="line">	p = p-&gt;next;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span> (p-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt;<span class="string">"data:"</span>&lt;&lt; p-&gt;data &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"data:"</span> &lt;&lt; p-&gt;data &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>4.删除结点</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//删除链表中的节点 </span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">detele_list_node</span><span class="params">(LNode* H, <span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//获取当前节点的位置</span></span><br><span class="line">	LNode* p = H;</span><br><span class="line">	LNode* pre = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (p-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="comment">//保存当前结点的前一个结点</span></span><br><span class="line">		pre = p;</span><br><span class="line">		<span class="comment">//然后P后移</span></span><br><span class="line">		p=p-&gt;next;</span><br><span class="line">		<span class="comment">//判断是否找到了要删除的数据</span></span><br><span class="line">		<span class="keyword">if</span> (p-&gt;data == data) &#123;</span><br><span class="line">			<span class="comment">//两种情况，一种是普通节点，还有一种是尾节点</span></span><br><span class="line">			<span class="comment">//普通节点</span></span><br><span class="line">			<span class="keyword">if</span> (p-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">				pre-&gt;next = p-&gt;next;</span><br><span class="line">				<span class="built_in">free</span>(p);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				pre -&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">				<span class="built_in">free</span>(p);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"没有要删除的节点!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>5.单链表逆置</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//链表逆置</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">trave_list</span><span class="params">(LNode* H)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//1.保存当前结点和第一个有效结点</span></span><br><span class="line">	LNode* p = H-&gt;next;</span><br><span class="line">	LNode* pBack;</span><br><span class="line">	<span class="comment">//2.若无有效结点或只有一个结点，则不进行任何操作</span></span><br><span class="line">	<span class="keyword">if</span> (p == <span class="literal">NULL</span> || p-&gt;next == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//3.遍历链表</span></span><br><span class="line">	<span class="keyword">while</span> (p-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="comment">//3.1 保存第一个结点的下一个结点的地址</span></span><br><span class="line">		pBack = p-&gt;next;</span><br><span class="line">		<span class="comment">//3.2 将第一个有效结点放入尾部</span></span><br><span class="line">		<span class="keyword">if</span> (p == H-&gt;next) &#123;</span><br><span class="line">			p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//3.3  如果不是第一个有效结点，则进行头插操作</span></span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			p-&gt;next = H-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">		H-&gt;next = p;</span><br><span class="line">		p = pBack;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//4.手动加入最后一个结点</span></span><br><span class="line">	top_insert(H, p); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="3-链表和顺序表的比较"><a href="#3-链表和顺序表的比较" class="headerlink" title="3.链表和顺序表的比较"></a>3.链表和顺序表的比较</h1><p><strong>1.顺序表存储（典型的数组）</strong><br>     原理：顺序表存储是将数据元素放到一块连续的内存存储空间，相邻数据元素的存放地址也相邻（逻辑与物理统一）。<br>     优点：（1）空间利用率高。（局部性原理，连续存放，命中率高）<br>           （2）存取速度高效，通过下标来直接存储。<br>     缺点：（1）插入和删除比较慢，比如：插入或者删除一个元素时，整个表需要遍历移动元素来重新排一次顺序。<br>           （2）不可以增长长度，有空间限制,当需要存取的元素个数可能多于顺序表的元素个数时,会出现”溢出”问题.当元素个数远少于预先分配的空间时,空间浪费巨大。<br>     时间性能 :查找 O(1) ,插入和删除O（n）。<br><strong>2.链表存储</strong><br>    原理：链表存储是在程序运行过程中动态的分配空间，只要存储器还有空间，就不会发生存储溢出问题，相邻数据元素可随意存放，但所占存储空间分两部分，一部分存放结点值，另一部分存放表示结点关系间的指针。<br>    优点：（1）存取某个元素速度慢。<br>          （2）插入和删除速度快，保留原有的物理顺序，比如：插入或者删除一个元素时，只需要改变指针指向即可。<br>          （3）没有空间限制,存储元素的个数无上限,基本只与内存空间大小有关.<br>    缺点：（1）占用额外的空间以存储指针(浪费空间，不连续存放，malloc开辟，空间碎片多)<br>          （2）查找速度慢，因为查找时，需要循环链表访问，需要从开始节点一个一个节点去查找元素访问。<br>    时间性能 :查找 O(n) ,插入和删除O（1）。<br><font color=red size=3><strong>*频繁的查找却很少的插入和删除操作可以用顺序表存储，堆排序,二分查找适宜用顺序表.<br>*如果频繁的插入和删除操作很少的查询就可以使用链表存储<br>*顺序表适宜于做查找这样的静态操作；链表适宜于做插入、删除这样的动态操作。<br>*若线性表长度变化不大，如果事先知道线性表的大致长度，比如一年12月，一周就是星期一至星期日共七天，且其主要操作是查找，则采用顺序表；若线性表长度变化较大或根本不知道多大时，且其主要操作是插入、删除，则采用链表，这样可以不需要考虑存储空间的大小问题。<br>*顺序表:顺序存储，随机读取<br>链式:随机存储,顺序读取(必须遍历)</strong></font></p>
]]></content>
  </entry>
  <entry>
    <title>暑假打卡第二天(双链表和循环链表)</title>
    <url>/2020/06/29/%E6%9A%91%E5%81%87%E6%89%93%E5%8D%A1%E7%AC%AC%E4%BA%8C%E5%A4%A9-%E5%8F%8C%E9%93%BE%E8%A1%A8%E5%92%8C%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<p>@<a href="目录">TOC</a></p>
<h1 id="1-双链表定义"><a href="#1-双链表定义" class="headerlink" title="1.双链表定义"></a>1.双链表定义</h1><p><font color="red"><strong>首先不管是单链表还是双链表或者循环双链表，都是为了提高访问效率，比如同样的插入操作，顺序表需要用数组移动元素，访问效率比较差，相反链表只需要移动指针，而且顺序表是有最大空间的，而链表没有。</strong></font></p>
<p>单链表只能由开始结点走到终端结点，而不能由终端结点走到开始结点。如果要求输出从终端结点到开始结点的序列，单链表操作起来非常麻烦，于是引入了双链表。双链表就是在单链表结点上增加了一个指针域，指向当前结点的前驱。</p>
<h1 id="2-双链表结点定义"><a href="#2-双链表结点定义" class="headerlink" title="2.双链表结点定义"></a>2.双链表结点定义</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DLNode</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> data;<span class="comment">//存放数据</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">DLNode</span>* <span class="title">prior</span>;</span><span class="comment">//指向前驱的指针</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">DLNode</span>* <span class="title">next</span>;</span><span class="comment">//指向后继的指针</span></span><br><span class="line">&#125;DLNode;</span><br></pre></td></tr></table></figure>
<h1 id="3-双链表的基本操作"><a href="#3-双链表的基本操作" class="headerlink" title="3.双链表的基本操作"></a>3.双链表的基本操作</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DLNode</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> data;<span class="comment">//存放数据</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">DLNode</span>* <span class="title">prior</span>;</span><span class="comment">//指向前驱的指针</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">DLNode</span>* <span class="title">next</span>;</span><span class="comment">//指向后继的指针</span></span><br><span class="line">&#125;DLNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建结点</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> DLNode* <span class="title">create_node</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//给每个结点分配大小一样的空间</span></span><br><span class="line">	DLNode* p = (DLNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DLNode));</span><br><span class="line">	<span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"结点空间分配失败!"</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//由于结构体在未初始化的时候一样是脏数据，所以要清</span></span><br><span class="line">	<span class="built_in">memset</span>(p, <span class="number">0</span>, <span class="keyword">sizeof</span>(DLNode*));</span><br><span class="line">	p-&gt;data = data;</span><br><span class="line">	p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">	p-&gt;prior = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//尾插法创建双链表</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">tail_insert</span><span class="params">(DLNode* L, <span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	DLNode* s, * r;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	r = L;<span class="comment">//r始终指向终端结点，开始头结点也是尾结点</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">		s = (DLNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DLNode));</span><br><span class="line">		s-&gt;data = a[i];</span><br><span class="line">		r-&gt;next = s;</span><br><span class="line">		s-&gt;prior = r;</span><br><span class="line">		r = s;</span><br><span class="line">	&#125;</span><br><span class="line">	r-&gt;next = <span class="literal">NULL</span>;        </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查找结点</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> DLNode* <span class="title">findNode</span><span class="params">(DLNode* C, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">	DLNode* p = C-&gt;next;</span><br><span class="line">	<span class="keyword">while</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (p-&gt;data == x) &#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取双链表的长度</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getListLength</span><span class="params">(DLNode* L)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (L-&gt;next == L)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"链表为空"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	DLNode* p;</span><br><span class="line">	p = L;</span><br><span class="line">	<span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (p-&gt;next != L)</span><br><span class="line">	&#123;</span><br><span class="line">		j++;</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入结点</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">insertNode</span><span class="params">(DLNode* L,<span class="keyword">int</span> i,<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (i&lt;<span class="number">1</span> || i&gt;getListLength(L))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"输入不合法！"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">	&#125;</span><br><span class="line">	DLNode *p, *q;</span><br><span class="line">	p = L;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i - <span class="number">1</span>; j++)   <span class="comment">//定位到要插入结点的前一个</span></span><br><span class="line">	&#123;</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	q = (DLNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DLNode*));</span><br><span class="line">	<span class="keyword">if</span> (!q)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"内存分配失败！"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">	&#125;</span><br><span class="line">	q-&gt;data = num;</span><br><span class="line">	q-&gt;next = p-&gt;next;</span><br><span class="line">	q-&gt;prior = p;</span><br><span class="line">	p-&gt;next = q;</span><br><span class="line">	q-&gt;next-&gt;prior = q;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印双链表</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printLinkedList</span><span class="params">(DLNode* L)</span> </span>&#123;</span><br><span class="line">	DLNode* p;</span><br><span class="line">	p = L;</span><br><span class="line">	<span class="keyword">if</span> (L-&gt;next == L)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"链表为空！"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; getListLength(L); i++)</span><br><span class="line">	&#123;</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; p-&gt;data &lt;&lt; <span class="string">"  "</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除结点</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">deleteListElem</span><span class="params">(DLNode* L, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (i&lt;<span class="number">1</span> || i&gt;getListLength(L))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"输入不合法！"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">	&#125;</span><br><span class="line">	DLNode *p, *q;</span><br><span class="line">	p = L;</span><br><span class="line">	<span class="keyword">int</span> j;</span><br><span class="line">	<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; i - <span class="number">1</span>; j++)   <span class="comment">//定位到要删除的结点的前一个</span></span><br><span class="line">	&#123;</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	q = p-&gt;next;</span><br><span class="line">	p-&gt;next = q-&gt;next;</span><br><span class="line">	q-&gt;next-&gt;prior = p;</span><br><span class="line">	<span class="built_in">free</span>(q);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="4-循环单链表"><a href="#4-循环单链表" class="headerlink" title="4.循环单链表"></a>4.循环单链表</h1><p><strong>1.知道了单链表结构后，循环单链表就非常简单了。只要将单链表的最后一个指针域（空指针）指向链表的第一个结点即可。</strong><br><font color="red"><strong>循环单链表可以实现从任何一个结点出发访问链表中的任何结点，而单链表从任一结点出发只能访问这个结点及其后边的所以结点。带头结点的循环单链表，当head等于head-&gt;next时，链表为空；不带头结点的循环单链表，当head等于NULL时，链表为空。</strong></font><br><img src="https://img-blog.csdnimg.cn/2020062911561238.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTE3MjA0Mw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><strong>2.单向循环链表的初始化：从上面的示意图可以知道，单向循环链表最后一个结点的指针是指向头结点的，那么当只有一个结点的时候就是头结点的指针指自己。</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> data;</span><br><span class="line">	LNode* next;</span><br><span class="line">&#125;LNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">//循环单链表</span></span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">init_node</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//创建一个头结点</span></span><br><span class="line">	LNode* H = (LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">	<span class="keyword">if</span> (H == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"初始化失败!"</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">memset</span>(H, <span class="number">0</span>, <span class="keyword">sizeof</span>(LNode*));</span><br><span class="line">	H-&gt;next = H;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>3.单向循环链表的创建过程：和单向链表的创建过程相似，区别就是最后一个结点的指针是指着头结点的。所以程序实现的时候每次新建一个结点的时候都是让它的指针指向头结点。</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//循环单链表</span></span><br><span class="line"><span class="comment">//创建结点</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> LNode* <span class="title">create_node</span><span class="params">(LNode* H,<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">	LNode* p = H;</span><br><span class="line">	<span class="comment">//给每个结点分配大小一样的空间</span></span><br><span class="line">	LNode* q = (LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">	<span class="keyword">if</span> (q == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"结点空间分配失败!"</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//由于结构体在未初始化的时候一样是脏数据，所以要清</span></span><br><span class="line">	<span class="built_in">memset</span>(q, <span class="number">0</span>, <span class="keyword">sizeof</span>(LNode*));</span><br><span class="line">	q-&gt;data = data;</span><br><span class="line">	p-&gt;next = q;</span><br><span class="line">	q-&gt;next = H;</span><br><span class="line">	<span class="keyword">return</span> q;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>4.单向循环链表插入结点过程：因为这个时候是往链表中插入结点，结点已经构成一个环了，所以直接让新插入结点的指针指向下一个结点就行。就算插入的是最后一个位置，让它的指针指向下一个结点也符合条件，因为最后一个位置的下一个结点就是头结点。</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在第i个位置之前插入元素</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">insertListElem</span><span class="params">(LinkedList&amp; L, <span class="keyword">int</span> i, <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (i&lt;<span class="number">1</span> || i&gt;getListLength(L))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"输入不合法！"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">	&#125;</span><br><span class="line">	LinkedList p, q;</span><br><span class="line">	p = L;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i - <span class="number">1</span>; j++)   <span class="comment">//定位到要插入结点的前一个</span></span><br><span class="line">	&#123;</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	q = (LinkedList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">	<span class="keyword">if</span> (!q)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"内存分配失败！"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">	&#125;</span><br><span class="line">	q-&gt;data = num;</span><br><span class="line">	q-&gt;next = p-&gt;next;</span><br><span class="line">	p-&gt;next = q;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>5.单向循环链表删除结点过程：结合单向链表删除结点过程和上面单向循环链表插入结点过程的解释，那么这里就不难理解了。</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//删除第i个元素</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">deleteListElem</span><span class="params">(LinkedList&amp; L, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (i&lt;<span class="number">1</span> || i&gt;getListLength(L))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"输入不合法！"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">	&#125;</span><br><span class="line">	LinkedList p, q;</span><br><span class="line">	p = L;</span><br><span class="line">	<span class="keyword">int</span> j;</span><br><span class="line">	<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; i - <span class="number">1</span>; j++)   <span class="comment">//定位到要删除的结点的前一个</span></span><br><span class="line">	&#123;</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	q = p-&gt;next;</span><br><span class="line">	p-&gt;next = p-&gt;next-&gt;next;</span><br><span class="line">	<span class="built_in">free</span>(q);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><font color="red"><strong>6.循环单链表的具体操作代码</strong></font></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"iostream"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;LNode, * LinkedList;</span><br><span class="line"><span class="comment">//创建链表</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">createLinkedList</span><span class="params">(LinkedList&amp; L, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (i &lt; <span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"输入不合法！"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">	&#125;</span><br><span class="line">	L = (LinkedList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">	<span class="keyword">if</span> (!L)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"内存分配失败!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">	&#125;</span><br><span class="line">	LinkedList p, q;</span><br><span class="line">	L-&gt;next = L;</span><br><span class="line">	p = L;</span><br><span class="line">	<span class="keyword">int</span> j;</span><br><span class="line">	<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; i; j++)</span><br><span class="line">	&#123;</span><br><span class="line">		q = (LinkedList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">		<span class="keyword">if</span> (!q)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="string">"内存分配失败！"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">			<span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"请输入第"</span> &lt;&lt; j + <span class="number">1</span> &lt;&lt; <span class="string">"个元素："</span>;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; q-&gt;data;</span><br><span class="line">		p-&gt;next = q;</span><br><span class="line">		q-&gt;next = L;</span><br><span class="line">		p = q;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取链表的长度</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getListLength</span><span class="params">(LinkedList&amp; L)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (L-&gt;next == L)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"链表为空"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	LinkedList p;</span><br><span class="line">	p = L;</span><br><span class="line">	<span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (p-&gt;next != L)</span><br><span class="line">	&#123;</span><br><span class="line">		j++;</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//打印链表</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printLinkedList</span><span class="params">(LinkedList&amp; L)</span> </span>&#123;</span><br><span class="line">	LinkedList p;</span><br><span class="line">	p = L;</span><br><span class="line">	<span class="keyword">if</span> (L-&gt;next == L)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"链表为空！"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; getListLength(L); i++)</span><br><span class="line">	&#123;</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; p-&gt;data &lt;&lt; <span class="string">"  "</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在第i个位置之前插入元素</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">insertListElem</span><span class="params">(LinkedList&amp; L, <span class="keyword">int</span> i, <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (i&lt;<span class="number">1</span> || i&gt;getListLength(L))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"输入不合法！"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">	&#125;</span><br><span class="line">	LinkedList p, q;</span><br><span class="line">	p = L;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i - <span class="number">1</span>; j++)   <span class="comment">//定位到要插入结点的前一个</span></span><br><span class="line">	&#123;</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	q = (LinkedList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">	<span class="keyword">if</span> (!q)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"内存分配失败！"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">	&#125;</span><br><span class="line">	q-&gt;data = num;</span><br><span class="line">	q-&gt;next = p-&gt;next;</span><br><span class="line">	p-&gt;next = q;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//删除第i个元素</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">deleteListElem</span><span class="params">(LinkedList&amp; L, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (i&lt;<span class="number">1</span> || i&gt;getListLength(L))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"输入不合法！"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">	&#125;</span><br><span class="line">	LinkedList p, q;</span><br><span class="line">	p = L;</span><br><span class="line">	<span class="keyword">int</span> j;</span><br><span class="line">	<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; i - <span class="number">1</span>; j++)   <span class="comment">//定位到要删除的结点的前一个</span></span><br><span class="line">	&#123;</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	q = p-&gt;next;</span><br><span class="line">	p-&gt;next = p-&gt;next-&gt;next;</span><br><span class="line">	<span class="built_in">free</span>(q);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//查找并返回第i个位置的元素</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getElem</span><span class="params">(LinkedList&amp; L, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (i&lt;<span class="number">1</span> || i&gt;getListLength(L))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"输入不合法！"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">	&#125;</span><br><span class="line">	LinkedList p;</span><br><span class="line">	p = L;</span><br><span class="line">	<span class="keyword">int</span> j;</span><br><span class="line">	<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; i; j++)</span><br><span class="line">	&#123;</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> p-&gt;data;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在链表中查找节点值等于num的位置，并返回</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">searchElem</span><span class="params">(LinkedList&amp; L, <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">	LinkedList p;</span><br><span class="line">	p = L-&gt;next;</span><br><span class="line">	<span class="keyword">int</span> j = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> ((p-&gt;data != num) &amp;&amp; (j &lt;= getListLength(L)))</span><br><span class="line">	&#123;</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">		j++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (j &lt;= getListLength(L))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> j;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"查找无该值！"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//销毁链表</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">destroylinkedlist</span><span class="params">(LinkedList&amp; L)</span> </span>&#123;</span><br><span class="line">	LinkedList p, q;</span><br><span class="line">	p = q = L-&gt;next;</span><br><span class="line">	<span class="keyword">while</span> (p != L)</span><br><span class="line">	&#123;</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">		<span class="built_in">free</span>(q);</span><br><span class="line">		q = p;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">free</span>(L);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//清空链表</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">clearList</span><span class="params">(LinkedList&amp; L)</span> </span>&#123;</span><br><span class="line">	LinkedList p, q;</span><br><span class="line">	p = q = L-&gt;next;</span><br><span class="line">	<span class="keyword">if</span> (L == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (p != L)</span><br><span class="line">	&#123;</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">		<span class="built_in">free</span>(q);</span><br><span class="line">		q = p;</span><br><span class="line">	&#125;</span><br><span class="line">	L-&gt;next = L;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>暑假打卡第三天(栈和队列)</title>
    <url>/2020/06/30/%E6%9A%91%E5%81%87%E6%89%93%E5%8D%A1%E7%AC%AC%E4%B8%89%E5%A4%A9-%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<p>@<a href="目录">toc</a></p>
<h1 id="一，栈的基本概念"><a href="#一，栈的基本概念" class="headerlink" title="一，栈的基本概念"></a>一，栈的基本概念</h1><h2 id="1，栈的定义"><a href="#1，栈的定义" class="headerlink" title="1，栈的定义"></a>1，栈的定义</h2><p><font color="red"><strong>栈是一种只能在一端进行插入或删除操作的线性表。</strong></font><br>其中允许插入或删除的一端成为栈顶(top)。表的另一端成为栈底，<font color="red"><strong>栈底是固定不变的。</strong></font></p>
<h2 id="2，栈的特点"><a href="#2，栈的特点" class="headerlink" title="2，栈的特点"></a>2，栈的特点</h2><p><font color="red"><strong>栈的主要特点是先进后出。</strong></font></p>
<h2 id="3，栈的存储结构"><a href="#3，栈的存储结构" class="headerlink" title="3，栈的存储结构"></a>3，栈的存储结构</h2><p><strong>可用顺序表和链表来存储栈。按照存储结构可分为两种:<br>(1)顺序栈基本操作：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxSize 50</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> data[maxSize];<span class="comment">//存放栈中元素</span></span><br><span class="line">	<span class="keyword">int</span> top;<span class="comment">//栈顶指针</span></span><br><span class="line">&#125;sqStack;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化栈</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">initStack</span><span class="params">(sqStack&amp; st)</span> </span>&#123;</span><br><span class="line">	st.top = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断栈空</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span>  <span class="title">isEmpty</span><span class="params">(sqStack&amp; st)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (st.top == <span class="number">-1</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//出栈</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">(sqStack&amp; st,<span class="keyword">int</span> &amp;x)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//出栈前先判断栈是否为空，如果栈空，则不能进行出栈操作</span></span><br><span class="line">	<span class="keyword">if</span> (st.top == <span class="number">-1</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	x = st.data[st.top];</span><br><span class="line">	st.top--;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//入栈</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">push</span><span class="params">(sqStack&amp; st, <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="comment">//出栈前先判断栈是否满，如果栈满，则不能进行入栈操作</span></span><br><span class="line">	<span class="keyword">if</span> (st.top == maxSize<span class="number">-1</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	st.top++;</span><br><span class="line">	st.data[st.top]=x;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>(2)链式栈基本操作：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> data;<span class="comment">//数据域</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>* <span class="title">next</span>;</span><span class="comment">//指针域</span></span><br><span class="line">&#125;LNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化栈</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">initStack</span><span class="params">(LNode*&amp; st)</span> </span>&#123;</span><br><span class="line">	st = (LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode*));<span class="comment">//制造一个头结点</span></span><br><span class="line">	st-&gt;next == <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断栈空</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span>  <span class="title">isEmpty</span><span class="params">(LNode*&amp; st)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (st-&gt;next==<span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//出栈</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">(LNode*&amp; st, <span class="keyword">int</span>&amp; x)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//出栈前先判断栈是否为空，如果栈空，则不能进行出栈操作</span></span><br><span class="line">	<span class="keyword">if</span> (st-&gt;next == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	LNode* p;</span><br><span class="line">	p = st-&gt;next;</span><br><span class="line">	x = p-&gt;data;</span><br><span class="line">	st-&gt;next = p-&gt;next;</span><br><span class="line">	<span class="built_in">free</span>(p);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//入栈</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(LNode*&amp; st, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">	LNode* p;</span><br><span class="line">	p = (LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode*));<span class="comment">//为入栈元素申请空间</span></span><br><span class="line">	p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	p-&gt;data = x;</span><br><span class="line">	p-&gt;next = st-&gt;next;</span><br><span class="line">	st-&gt;next = p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="二，队列的基本概念"><a href="#二，队列的基本概念" class="headerlink" title="二，队列的基本概念"></a>二，队列的基本概念</h1><h2 id="1，队列的定义"><a href="#1，队列的定义" class="headerlink" title="1，队列的定义"></a>1，队列的定义</h2><p><font color="red"><strong>队列是一种只能在一端进行插入，在另一端进行删除操作的线性表。</strong></font><br>其中允许插的一端成为队尾(rear)，可进行删除的一端称为队头(front).</p>
<h2 id="2，队列的特点"><a href="#2，队列的特点" class="headerlink" title="2，队列的特点"></a>2，队列的特点</h2><p><font color="red"><strong>队列的主要特点是先进先出。</strong></font></p>
<h2 id="3，队列的存储结构"><a href="#3，队列的存储结构" class="headerlink" title="3，队列的存储结构"></a>3，队列的存储结构</h2><p><strong>可用顺序表和链表来存储队列。按照存储结构可分为两种:<br>(1)顺序队列基本操作：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxSize 50</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> data[maxSize];</span><br><span class="line">	<span class="keyword">int</span> front;<span class="comment">//队首指针</span></span><br><span class="line">	<span class="keyword">int</span> rear;<span class="comment">//队尾指针</span></span><br><span class="line">&#125;sqQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化队列</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">initQueue</span><span class="params">(sqQueue&amp; qu)</span> </span>&#123;</span><br><span class="line">	qu.front = qu.rear = <span class="number">0</span>;<span class="comment">//队头和队尾相等且为0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判空</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">isEmpty</span><span class="params">(sqQueue&amp; qu)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (qu.front == qu.rear) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//入队</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">enQueue</span><span class="params">(sqQueue&amp; qu,<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//先判断队列是否满</span></span><br><span class="line">	<span class="keyword">if</span> ((qu.rear + <span class="number">1</span>) % maxSize == qu.front) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//在这里存入元素和移动指针顺序无所谓（和栈不同）</span></span><br><span class="line">	qu.data[qu.rear] = x;</span><br><span class="line">	qu.rear = (qu.rear + <span class="number">1</span>)%maxSize;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//出队</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">deQueue</span><span class="params">(sqQueue&amp; qu, <span class="keyword">int</span>&amp; x)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//先判断队列是否为空</span></span><br><span class="line">	<span class="keyword">if</span> (qu.rear == qu.front) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	qu.front = (qu.front + <span class="number">1</span>) % maxSize;</span><br><span class="line">	x = qu.data[qu.front];</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>(2)链队的基本操作：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">QNode</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">QNode</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;QNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	QNode* front;<span class="comment">//队首指针</span></span><br><span class="line">	QNode* rear;<span class="comment">//队尾指针</span></span><br><span class="line">&#125;LiQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">initQueue</span><span class="params">(LiQueue*&amp; lqu)</span> </span>&#123;</span><br><span class="line">	lqu= (LiQueue*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LiQueue*));</span><br><span class="line">	lqu-&gt;front = lqu-&gt;rear = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判空</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">isEmpty</span><span class="params">(LiQueue* lqu)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (lqu-&gt;front == <span class="literal">NULL</span> || lqu-&gt;rear == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//入队</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">enQueue</span><span class="params">(LiQueue* lqu, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">	QNode* p;</span><br><span class="line">	p= (QNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(QNode*));</span><br><span class="line">	p-&gt;data = x;</span><br><span class="line">	p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">if</span> (lqu-&gt;rear == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		lqu-&gt;rear-&gt;next = p;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		lqu-&gt;rear-&gt;next = p;</span><br><span class="line">		lqu-&gt;rear = p;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//出队</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">deQueue</span><span class="params">(LiQueue* lqu, <span class="keyword">int</span>&amp; x)</span> </span>&#123;</span><br><span class="line">	QNode* p;</span><br><span class="line">	<span class="comment">//先判空</span></span><br><span class="line">	<span class="keyword">if</span> (lqu-&gt;rear == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		p = lqu-&gt;front;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (lqu-&gt;front == lqu-&gt;rear) &#123;</span><br><span class="line">		lqu-&gt;front = lqu-&gt;rear = <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		lqu-&gt;front = lqu-&gt;front-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	x = p-&gt;data;</span><br><span class="line">	<span class="built_in">free</span>(p);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>暑假打卡第四天(串)</title>
    <url>/2020/07/02/%E6%9A%91%E5%81%87%E6%89%93%E5%8D%A1%E7%AC%AC%E5%9B%9B%E5%A4%A9-%E4%B8%B2/</url>
    <content><![CDATA[<p>@[toc]</p>
<h2 id="1，串的定义"><a href="#1，串的定义" class="headerlink" title="1，串的定义"></a>1，串的定义</h2><p><strong>串是由零个或多个字符组成的有限序列。串中字符的个数称为串的长度，含有零个元素的叫空串。</strong><br><font color="red"> <strong>注：由一个或多个空格组成的叫空格串，空格串不是空串</strong> </font></p>
<h2 id="2，串的存储结构"><a href="#2，串的存储结构" class="headerlink" title="2，串的存储结构"></a>2，串的存储结构</h2><p>（1）定长顺序存储表示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">	<span class="keyword">char</span> str[maxSize+<span class="number">1</span>];</span><br><span class="line">	<span class="keyword">int</span> len;</span><br><span class="line">&#125;Str;</span><br></pre></td></tr></table></figure>
<p>（2）变长分配存储表示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">	<span class="keyword">char</span> *ch;</span><br><span class="line">	<span class="keyword">int</span> len;</span><br><span class="line">&#125;Str;</span><br></pre></td></tr></table></figure>
<h2 id="3，串的基本操作"><a href="#3，串的基本操作" class="headerlink" title="3，串的基本操作"></a>3，串的基本操作</h2><p>(1)赋值操作</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//赋值操作</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">strassign</span><span class="params">(Str &amp;str,<span class="keyword">char</span> *ch)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(str.ch)&#123;</span><br><span class="line">		<span class="built_in">free</span>(str.ch);<span class="comment">//先清空str串 </span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> len=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">char</span> *c;</span><br><span class="line">	<span class="keyword">while</span>(*c)&#123;</span><br><span class="line">		len++;<span class="comment">//求ch串的长度 </span></span><br><span class="line">		c++;</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="comment">//如果ch串为空，则str也置为空 </span></span><br><span class="line">	<span class="keyword">if</span>(len==<span class="number">0</span>)&#123;</span><br><span class="line">		str.len=<span class="number">0</span>;</span><br><span class="line">		str.ch=<span class="literal">NULL</span>;</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		str.ch=(<span class="keyword">char</span>*)<span class="built_in">malloc</span>(szieof(<span class="keyword">char</span>*)*(len+<span class="number">1</span>));</span><br><span class="line">		<span class="keyword">if</span>(str.ch==<span class="literal">NULL</span>)&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			c=ch;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">				str.ch[i]=*c;</span><br><span class="line">				str.len=len;</span><br><span class="line">				<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(2)取串长度操作</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//取串长度操作</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">strlength</span><span class="params">(Str str)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> str.len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(3)串比较操作</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//串比较操作</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">strcompare</span><span class="params">(Str str1,Str str2)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;str1.len &amp;&amp; i&lt;str2.len;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(str1.ch[i]!=str2.ch[i])&#123;</span><br><span class="line">			<span class="keyword">return</span> str1.ch[i]-str2.ch[i];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> str1.len-str2.len;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(4)串连接操作</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//串连接操作</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">concat</span><span class="params">(Str &amp;str,Str str1,Str str2)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(str.ch)&#123;</span><br><span class="line">		<span class="built_in">free</span>(str.ch);<span class="comment">//先清空str串</span></span><br><span class="line">		str.ch=<span class="literal">NULL</span>; </span><br><span class="line">	&#125;</span><br><span class="line">	str.ch=(<span class="keyword">char</span>*)<span class="built_in">malloc</span>(szieof(<span class="keyword">char</span>*)*(str1.len+str2.len+<span class="number">1</span>));</span><br><span class="line">		<span class="keyword">if</span>(str.ch==<span class="literal">NULL</span>)&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span>(i&lt;str1.len)&#123;</span><br><span class="line">			str.ch[i]=str1.ch[i];</span><br><span class="line">			i++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span>(j&lt;=str2.len)&#123;</span><br><span class="line">			str.ch[j+i]=str2.ch[j];</span><br><span class="line">			j++;</span><br><span class="line">		&#125;</span><br><span class="line">		str.len=str1.len+str2.len;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(5)串清空操作</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//串清空操作</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">clearstring</span><span class="params">(Str &amp;str)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(str.ch)&#123;</span><br><span class="line">		<span class="built_in">free</span>(str.ch);</span><br><span class="line">		str.ch=<span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	str.len=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>暑假打卡第五天(树与二叉树)</title>
    <url>/2020/07/03/%E6%9A%91%E5%81%87%E6%89%93%E5%8D%A1%E7%AC%AC%E4%BA%94%E5%A4%A9-%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<p>@[toc]</p>
<h2 id="一，树的基本概念"><a href="#一，树的基本概念" class="headerlink" title="一，树的基本概念"></a>一，树的基本概念</h2><h3 id="1，树的定义："><a href="#1，树的定义：" class="headerlink" title="1，树的定义："></a>1，树的定义：</h3><p><font color="red"><strong>树形结构是一种典型的非线性数据结构，体现在数据元素之间有明显的层次关系。</strong></font><br><strong>树是由n个节点构成的有限集合，n大于等于零，节点数为零的树称为空树，节点数大于零的树称为非空树。<br>一棵非空树满足以下条件：</strong><br><font color="red"><strong>（1）有且仅有一个被称为根的特殊节点，其余所有节点都可由根节点经过一定的分支得到，而根结点R没有前驱节点。<br>（2）当n&gt;1时，除根节点R外的其它节点被分成m个互不相交的子集，T1,T2,….Tm，其中每个子集Ti本身又是一棵树，被称为R节点的子树。<br>树的定义是递归定义，即每个子树的定义也是按照上面的过程完成的。</strong></font></p>
<h3 id="2，树的基本术语"><a href="#2，树的基本术语" class="headerlink" title="2，树的基本术语"></a>2，树的基本术语</h3><p><font color="red"><strong>（1）节点：节点由数据元素和构造元素之间关系的组成。<br>（2）节点的度：节点拥有的子树的个数称为该节点的度。<br>（3）树的度:树中各节点度最大值称为该树的度。<br>（4）叶子节点：将度为0的节点称为叶子节点，又称为终端节点<br>（5）分支节点：   将度不为0的节点称为分支节点，又称为非终端节点。<br>（6）节点的层次：从根节点到树中某节点所经路径上的边数加1称为该节点的层次。<br>（7）树的深度：树中所有节点的层次的最大值称为该树的深度。</strong></font></p>
<h2 id="二，二叉树的基本概念"><a href="#二，二叉树的基本概念" class="headerlink" title="二，二叉树的基本概念"></a>二，二叉树的基本概念</h2><h3 id="1，二叉树的定义"><a href="#1，二叉树的定义" class="headerlink" title="1，二叉树的定义"></a>1，二叉树的定义</h3><p><font color="red"><strong>二叉树是由n个节点构成的有限集合，n大于等于零，每个节点的最多有两个子树的有序树。</strong></font><br><strong>二叉树的特点如下：<br>（1）二叉树是有序树，即使只有一个子树，也必须区分左、右子树。<br>（2）二叉树的每个节点的度不能大于2，只能取0、1、2三者中的一个。<br>（3）二叉树中所有节点的形态有5种，空节点、无左右子树的节点、只有左子树的节点、只有右子树的节点、同时具有左右子树的节点。</strong></p>
<h3 id="2，二叉的性质"><a href="#2，二叉的性质" class="headerlink" title="2，二叉的性质"></a>2，二叉的性质</h3><p><font color="blue"><strong>性质1  二叉树的第i层上最多有2i-1个节点。<br>性质2  深度为h的二叉树上最多有2h-1个节点<br>性质3  具有n个节点的二叉树的高度不小于Log2(n+1)的最大整数<br>性质4  在任意一棵二叉树中，如果叶子节点的个数为n1,度为2的节点个数为n2,则n1=n2+1.<br>性质5  具有n个节点的完全二叉树的高度为Log2(n+1)。<br>性质6  假定对一颗有n个节点的完全二叉树中的节点，按从上到下，从左到右的顺序，从1到n编号，设树中某一个节点的序号为i，i&lt;=i&lt;=n.同，则有如下关系：<br>①若i等于1，则该节点为二叉树的根。<br>②若i大于1，则该节点喘气双亲节点的序号为i/2.<br>③若2i&lt;=n,则该节点的左孩子节点的序号为2i,否则该 节点无左孩子节点。<br>④若2i+1&lt;=n,则该节点的右孩子节点的序号为2i+1,否则该节点无右孩子节点。</strong></p>
<h3 id="3，特殊二叉树"><a href="#3，特殊二叉树" class="headerlink" title="3，特殊二叉树"></a>3，特殊二叉树</h3><p><strong>满二叉树：若深度为h的二叉树，恰好具有2h-1个节点则该树称为满二叉树。<br>完全二叉树：若一棵具有n个节点的二叉树的逻辑结构与满二叉树的前n个节点的逻辑结构完全相同，则称该二叉树为完全二叉树。</strong></p>
<h3 id="4，二叉树的存储结构"><a href="#4，二叉树的存储结构" class="headerlink" title="4，二叉树的存储结构"></a>4，二叉树的存储结构</h3><p><strong>二叉树的存储结构有顺序存储结构 、链式存储结构和仿真指针存储结构</strong><br><strong>（1）顺序存储结构<br>  <font color="blue">顺序存储结构也就是采用一维数组存储的。根据二叉树的性质6可以计算出双亲节点、左右孩子节点的下标。因此满二叉树、完全二叉树的存储可采用一维数组存储。</strong></font><br><font color="red"><strong>注意：一般的二叉树不宜采用顺序存储，这是由于如果采用该方法存储，不能确定一棵普通二叉树的各种关系。如果需要采用顺序存储结构存储一棵普通二叉树，可为一棵普通的二叉树增添一些并不存在的节点使之变成完全二叉树的形态，然后再采用顺序存储结构存储。</strong></font></p>
<p><strong>（2）链式存储结构<br><font color="blue">链式存储结构采用链表存储二叉树中的数据元素。</strong></font><br><font color="##56f"><br><strong>二叉树中最常见的链式存储结构是二叉链，每一个节点包含3个域，分别是数据元素或data,左孩子域lChild和右孩子域rChild，<br>其节点结构：<br>二叉树的二叉链存储结构是常用的存储结构，<br>优点：结构简单，可方便地构造任何二叉树，可实现二叉树的大多数操作。<br>缺点：难以查找当前节点的双亲节点。（可采用三叉链存储结构解决这个问题，就是在二叉存储结构上再增加一个双亲节点的链域parent）</strong></font></p>
<h3 id="5，二叉树的基本操作"><a href="#5，二叉树的基本操作" class="headerlink" title="5，二叉树的基本操作"></a>5，二叉树的基本操作</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span><span class="comment">//定义二叉树结构</span></span><br><span class="line">    <span class="keyword">char</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">lchild</span>,*<span class="title">rchild</span>;</span></span><br><span class="line">&#125;*BiTree,BiTNode;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateBiTree</span><span class="params">(BiTree &amp;T)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//先序创建二叉树</span></span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;ch;</span><br><span class="line">    <span class="keyword">if</span>(ch==<span class="string">'#'</span>) T=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        T=<span class="keyword">new</span> BiTNode;</span><br><span class="line">        T-&gt;data=ch;</span><br><span class="line">        CreateBiTree(T-&gt;lchild);</span><br><span class="line">        CreateBiTree(T-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrderTraverse</span><span class="params">(BiTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//中序遍历</span></span><br><span class="line">    <span class="keyword">if</span>(T)</span><br><span class="line">    &#123;</span><br><span class="line">        InOrderTraverse(T-&gt;lchild);</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;T-&gt;data;</span><br><span class="line">        InOrderTraverse(T-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrderTraverse</span><span class="params">(BiTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//先序遍历</span></span><br><span class="line">    <span class="keyword">if</span>(T)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;T-&gt;data;</span><br><span class="line">        PreOrderTraverse(T-&gt;lchild);</span><br><span class="line">        PreOrderTraverse(T-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostOrderTraverse</span><span class="params">(BiTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//后序遍历</span></span><br><span class="line">    <span class="keyword">if</span>(T)</span><br><span class="line">    &#123;</span><br><span class="line">        PostOrderTraverse(T-&gt;lchild);</span><br><span class="line">        PostOrderTraverse(T-&gt;rchild);</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;T-&gt;data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Copy</span><span class="params">(BiTree T,BiTree &amp;NewT)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//二叉树的复制</span></span><br><span class="line">    <span class="keyword">if</span>(T==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        NewT=<span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        NewT=<span class="keyword">new</span> BiTNode;</span><br><span class="line">        NewT-&gt;data=T-&gt;data;</span><br><span class="line">        Copy(T-&gt;lchild,NewT-&gt;lchild);</span><br><span class="line">        Copy(T-&gt;rchild,NewT-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Depth</span><span class="params">(BiTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//树的深度</span></span><br><span class="line">    <span class="keyword">if</span>(T==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> m=Depth(T-&gt;lchild);</span><br><span class="line">        <span class="keyword">int</span> n=Depth(T-&gt;rchild);</span><br><span class="line">        <span class="keyword">if</span>(m&gt;n) <span class="keyword">return</span> (m+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> (n+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">NodeCount</span><span class="params">(BiTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//统计二叉树中结点的个数</span></span><br><span class="line">    <span class="keyword">if</span>(T==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> NodeCount(T-&gt;lchild)+NodeCount(T-&gt;rchild)+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LeafCount</span><span class="params">(BiTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//统计二叉树中叶子结点的个数</span></span><br><span class="line">    <span class="keyword">if</span>(!T) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(!T-&gt;lchild &amp;&amp;!T-&gt;rchild)&#123;<span class="comment">//如果二叉树左子树和右子树皆为空,说明该二叉树根节点为叶子节点,加1.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> LeafCount(T-&gt;lchild)+LeafCount(T-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Node_1_Count</span><span class="params">(BiTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//统计二叉树的度为1的结点个数</span></span><br><span class="line">    <span class="keyword">if</span>(!T) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>((!T-&gt;lchild)&amp;&amp;(T-&gt;rchild)||(T-&gt;lchild)&amp;&amp;(!T-&gt;rchild))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + Node_1_Count(T-&gt;lchild) + Node_1_Count(T-&gt;rchild);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> Node_1_Count(T-&gt;lchild) + Node_1_Count(T-&gt;rchild);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintAllPath</span><span class="params">(BiTree T, <span class="keyword">char</span> path[], <span class="keyword">int</span> pathlen)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//二叉树中从每个叶子结点到根结点的路径</span></span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="keyword">if</span>(T != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    path[pathlen] = T-&gt;data; <span class="comment">//将当前结点放入路径中</span></span><br><span class="line">    <span class="keyword">if</span>(T-&gt;lchild == <span class="literal">NULL</span> &amp;&amp; T-&gt;rchild == <span class="literal">NULL</span>) &#123;<span class="comment">//叶子结点</span></span><br><span class="line">        <span class="keyword">for</span>(i = pathlen; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; path[i] &lt;&lt; <span class="string">" "</span> ;</span><br><span class="line">      <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      PrintAllPath(T-&gt;lchild, path, pathlen + <span class="number">1</span>);</span><br><span class="line">      PrintAllPath(T-&gt;rchild, path, pathlen + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ExChangeTree</span><span class="params">(BiTree &amp;T)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//构造函数，使用递归算法进行左右结点转换</span></span><br><span class="line">    BiTree temp;</span><br><span class="line">    <span class="keyword">if</span>(T!=<span class="literal">NULL</span>)&#123;<span class="comment">//判断T是否为空，非空进行转换，否则不转换</span></span><br><span class="line">        temp=T-&gt;lchild;</span><br><span class="line">        T-&gt;lchild=T-&gt;rchild;<span class="comment">//直接交换节点地址</span></span><br><span class="line">        T-&gt;rchild=temp;</span><br><span class="line">        ExChangeTree(T-&gt;lchild);</span><br><span class="line">        ExChangeTree(T-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DblOrderTraverse</span><span class="params">(BiTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//二叉树的双序遍历</span></span><br><span class="line">    <span class="keyword">if</span>(T)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;T-&gt;data;</span><br><span class="line">        DblOrderTraverse(T-&gt;lchild);</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;T-&gt;data;<span class="comment">//访问两遍</span></span><br><span class="line">        DblOrderTraverse(T-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BiTree T;</span><br><span class="line">    <span class="comment">//测试例子AB#CD##E##F#GH###</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"先序遍历输入(以#结束):"</span>;</span><br><span class="line">    CreateBiTree(T);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"中序遍历输出:"</span>;</span><br><span class="line">    InOrderTraverse(T);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>&lt;&lt;<span class="string">"先序遍历输出:"</span>;</span><br><span class="line">    PreOrderTraverse(T);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>&lt;&lt;<span class="string">"后序遍历输出:"</span>;</span><br><span class="line">    PostOrderTraverse(T);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>&lt;&lt;<span class="string">"树的深度:"</span>&lt;&lt;Depth(T);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>&lt;&lt;<span class="string">"结点的个数:"</span>&lt;&lt;NodeCount(T);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>&lt;&lt;<span class="string">"叶结点的个数:"</span>&lt;&lt;LeafCount(T);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>&lt;&lt;<span class="string">"度为1的结点个数:"</span>&lt;&lt;Node_1_Count(T);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>&lt;&lt;<span class="string">"二叉树中从每个叶子结点到根结点的所有路径："</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">char</span> path[<span class="number">256</span>];</span><br><span class="line">    <span class="keyword">int</span> pathlen=<span class="number">0</span>;</span><br><span class="line">    PrintAllPath(T,path,pathlen);<span class="comment">//</span></span><br><span class="line">    <span class="comment">//交换二叉树每个结点的左孩子和右孩子</span></span><br><span class="line">    BiTree tem=T;<span class="comment">//直接复制一颗树，在不改变原树的前提下，对临时树进行交换。</span></span><br><span class="line">    ExChangeTree(tem);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"先序遍历输出交换后的结果:"</span>;</span><br><span class="line">    PreOrderTraverse(tem);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>&lt;&lt;<span class="string">"双序遍历输出:"</span>;</span><br><span class="line">    DblOrderTraverse(T);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><font color="red"><strong>未完待续…..</strong></font></p>
]]></content>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
</search>
