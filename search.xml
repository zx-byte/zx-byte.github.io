<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2020/06/28/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>我的第一篇博客</title>
    <url>/2020/06/28/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2-1/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>我的第一篇博客</title>
    <url>/2020/06/28/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<p><strong>我的第一篇博客</strong><br><strong>好看吗?</strong></p>
]]></content>
  </entry>
  <entry>
    <title>暑假打卡第一天（单链表）</title>
    <url>/2020/06/28/%E6%9A%91%E5%81%87%E6%89%93%E5%8D%A1%E7%AC%AC%E4%B8%80%E5%A4%A9%EF%BC%88%E5%8D%95%E9%93%BE%E8%A1%A8%EF%BC%89/</url>
    <content><![CDATA[<p>@<a href="目录">TOC</a></p>
<h1 id="1-单链表结点定义"><a href="#1-单链表结点定义" class="headerlink" title="1.单链表结点定义"></a>1.单链表结点定义</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> data;<span class="comment">//data中存放结点数据域</span></span><br><span class="line">	LNode* next;<span class="comment">//指向后继结点的指针</span></span><br><span class="line">&#125;LNode;<span class="comment">//定义单链表结点类型</span></span><br></pre></td></tr></table></figure>

<p>结点时内存中一片由用户分配的存储空间，只有一个地址来表示它的存在，没有显式的名称，因此一般会在分配链表结点空间的时候，同时定义一个指针，来存储这片空间的地址（这个过程一般叫做指针指向结点），并且通常用这个指针的名称作为结点的名称。<br>例如，下边这句代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">LNode* p = (LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br></pre></td></tr></table></figure>

<p>用户分配了一片<font color=red size=3><strong>LNode</strong></font>型空间，也就是构造了一个<font color=red size=3><strong>LNode</strong></font>型的结点，这时候定义一个名字为p的指针来指向这个结点，同时我们也把p当作这个结点的名字。<br> <font color=red size=3> <strong>注：这里的命名了两个东西，一个是结点，另一个是指向这个结点的指针。</strong></font></p>
<h1 id="2-单链表的操作"><a href="#2-单链表的操作" class="headerlink" title="2.单链表的操作"></a>2.单链表的操作</h1><p><strong>1.创建结点</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建结点</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> LNode* <span class="title">create_node</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//给每个结点分配大小一样的空间</span></span><br><span class="line">	LNode* p = (LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">	<span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"结点空间分配失败!"</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//由于结构体在未初始化的时候一样是脏数据，所以要清</span></span><br><span class="line">	<span class="built_in">memset</span>(p, <span class="number">0</span>, <span class="keyword">sizeof</span>(LNode*));</span><br><span class="line">	p-&gt;data = data;</span><br><span class="line">	p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2.插入结点</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//尾插法</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">tail_insert</span><span class="params">(LNode* H, LNode* New)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//获取当前节点的位置</span></span><br><span class="line">	LNode* p = H;</span><br><span class="line">	<span class="comment">//遍历链表，直到找到最后一个结点</span></span><br><span class="line">	<span class="keyword">while</span> (p-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		p=p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//如果跳出以上循环，所以已经到了NULL的这个位置</span></span><br><span class="line">	<span class="comment">//此时直接把新插入的节点赋值给NULL这个位置 </span></span><br><span class="line">	p-&gt;next = New;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//头插法</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">top_insert</span><span class="params">(LNode* H, LNode* New)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//获取当前节点的位置</span></span><br><span class="line">	LNode* p = H;</span><br><span class="line">	New-&gt;next = p-&gt;next;</span><br><span class="line">	p-&gt;next = New;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>3.遍历单链表</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//链表的遍历 </span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Print_node</span><span class="params">(LNode* H)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//获取当前节点的位置</span></span><br><span class="line">	LNode* p = H;</span><br><span class="line">	<span class="comment">//获取当前结点的下一位置</span></span><br><span class="line">	p = p-&gt;next;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span> (p-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt;<span class="string">"data:"</span>&lt;&lt; p-&gt;data &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"data:"</span> &lt;&lt; p-&gt;data &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>4.删除结点</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//删除链表中的节点 </span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">detele_list_node</span><span class="params">(LNode* H, <span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//获取当前节点的位置</span></span><br><span class="line">	LNode* p = H;</span><br><span class="line">	LNode* pre = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (p-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="comment">//保存当前结点的前一个结点</span></span><br><span class="line">		pre = p;</span><br><span class="line">		<span class="comment">//然后P后移</span></span><br><span class="line">		p=p-&gt;next;</span><br><span class="line">		<span class="comment">//判断是否找到了要删除的数据</span></span><br><span class="line">		<span class="keyword">if</span> (p-&gt;data == data) &#123;</span><br><span class="line">			<span class="comment">//两种情况，一种是普通节点，还有一种是尾节点</span></span><br><span class="line">			<span class="comment">//普通节点</span></span><br><span class="line">			<span class="keyword">if</span> (p-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">				pre-&gt;next = p-&gt;next;</span><br><span class="line">				<span class="built_in">free</span>(p);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				pre -&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">				<span class="built_in">free</span>(p);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"没有要删除的节点!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>5.单链表逆置</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//链表逆置</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">trave_list</span><span class="params">(LNode* H)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//1.保存当前结点和第一个有效结点</span></span><br><span class="line">	LNode* p = H-&gt;next;</span><br><span class="line">	LNode* pBack;</span><br><span class="line">	<span class="comment">//2.若无有效结点或只有一个结点，则不进行任何操作</span></span><br><span class="line">	<span class="keyword">if</span> (p == <span class="literal">NULL</span> || p-&gt;next == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//3.遍历链表</span></span><br><span class="line">	<span class="keyword">while</span> (p-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="comment">//3.1 保存第一个结点的下一个结点的地址</span></span><br><span class="line">		pBack = p-&gt;next;</span><br><span class="line">		<span class="comment">//3.2 将第一个有效结点放入尾部</span></span><br><span class="line">		<span class="keyword">if</span> (p == H-&gt;next) &#123;</span><br><span class="line">			p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//3.3  如果不是第一个有效结点，则进行头插操作</span></span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			p-&gt;next = H-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">		H-&gt;next = p;</span><br><span class="line">		p = pBack;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//4.手动加入最后一个结点</span></span><br><span class="line">	top_insert(H, p); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="3-链表和顺序表的比较"><a href="#3-链表和顺序表的比较" class="headerlink" title="3.链表和顺序表的比较"></a>3.链表和顺序表的比较</h1><p><strong>1.顺序表存储（典型的数组）</strong><br>     原理：顺序表存储是将数据元素放到一块连续的内存存储空间，相邻数据元素的存放地址也相邻（逻辑与物理统一）。<br>     优点：（1）空间利用率高。（局部性原理，连续存放，命中率高）<br>           （2）存取速度高效，通过下标来直接存储。<br>     缺点：（1）插入和删除比较慢，比如：插入或者删除一个元素时，整个表需要遍历移动元素来重新排一次顺序。<br>           （2）不可以增长长度，有空间限制,当需要存取的元素个数可能多于顺序表的元素个数时,会出现”溢出”问题.当元素个数远少于预先分配的空间时,空间浪费巨大。<br>     时间性能 :查找 O(1) ,插入和删除O（n）。<br><strong>2.链表存储</strong><br>    原理：链表存储是在程序运行过程中动态的分配空间，只要存储器还有空间，就不会发生存储溢出问题，相邻数据元素可随意存放，但所占存储空间分两部分，一部分存放结点值，另一部分存放表示结点关系间的指针。<br>    优点：（1）存取某个元素速度慢。<br>          （2）插入和删除速度快，保留原有的物理顺序，比如：插入或者删除一个元素时，只需要改变指针指向即可。<br>          （3）没有空间限制,存储元素的个数无上限,基本只与内存空间大小有关.<br>    缺点：（1）占用额外的空间以存储指针(浪费空间，不连续存放，malloc开辟，空间碎片多)<br>          （2）查找速度慢，因为查找时，需要循环链表访问，需要从开始节点一个一个节点去查找元素访问。<br>    时间性能 :查找 O(n) ,插入和删除O（1）。<br><font color=red size=3><strong>*频繁的查找却很少的插入和删除操作可以用顺序表存储，堆排序,二分查找适宜用顺序表.<br>*如果频繁的插入和删除操作很少的查询就可以使用链表存储<br>*顺序表适宜于做查找这样的静态操作；链表适宜于做插入、删除这样的动态操作。<br>*若线性表长度变化不大，如果事先知道线性表的大致长度，比如一年12月，一周就是星期一至星期日共七天，且其主要操作是查找，则采用顺序表；若线性表长度变化较大或根本不知道多大时，且其主要操作是插入、删除，则采用链表，这样可以不需要考虑存储空间的大小问题。<br>*顺序表:顺序存储，随机读取<br>链式:随机存储,顺序读取(必须遍历)</strong></font></p>
]]></content>
  </entry>
</search>
